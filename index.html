<html>
  <head>
    <meta charset="utf-8" />
    <style>
      body {
        font-size: 2vh;
      }
      @media(prefers-color-scheme:dark){body{background-color:rgb(50,54,57);}}
    </style>
    <title>Tetris</title>
  </head>
  <body>
    <script>
const WIDTH = 12
const HEIGHT = WIDTH * 2
const EMPTY_BLOCK = ' '
const SOLID_BLOCK = '▢' // ▦ ▣
const scoreAnimal = '🐒'
const MS_PER_TICK = 1000 / 60 // ms for 60FPS
const TICKS_TILL_FALL = 40
const TOUCH_MOVE_THRESHOLD = 100
const FALL_SPEED = 40
const PIECES = [
  [
    SOLID_BLOCK,
    SOLID_BLOCK,
    SOLID_BLOCK,
    SOLID_BLOCK,
  ],
  [
    `${SOLID_BLOCK}${SOLID_BLOCK}`,
    `${SOLID_BLOCK}${SOLID_BLOCK}`,
  ],
  [
    `${SOLID_BLOCK} `,
    `${SOLID_BLOCK} `,
    `${SOLID_BLOCK}${SOLID_BLOCK}`,
  ],
  [
    `${SOLID_BLOCK}${SOLID_BLOCK} `,
    ` ${SOLID_BLOCK}${SOLID_BLOCK}`,
  ],
  [
    ` ${SOLID_BLOCK}${SOLID_BLOCK}`,
    `${SOLID_BLOCK}${SOLID_BLOCK} `,
  ],
  [
    ` ${SOLID_BLOCK}`,
    ` ${SOLID_BLOCK}`,
    `${SOLID_BLOCK}${SOLID_BLOCK}`,
  ],
  [
    `${SOLID_BLOCK} `,
    `${SOLID_BLOCK}${SOLID_BLOCK}`,
    `${SOLID_BLOCK} `,
  ],
]

const getRandomPiece = () => PIECES[Math.floor(Math.random() * PIECES.length)]

const getGrid = () => new Array(HEIGHT).fill(undefined).map(a => new Array(WIDTH).fill(EMPTY_BLOCK))

function drawPiece(grid, piece, x, y, clear = false) {
  const newGrid = [...grid.map(line => [...line])]
  for (lineIndex in piece) {
    const line = piece[lineIndex].split('')

    for (rowIndex in line) {
      const gridY = parseInt(lineIndex) + y
      const gridX = parseInt(rowIndex) + x

      if (newGrid[gridY] === undefined || newGrid[gridX] === undefined) {
        continue
      }

      if (piece[lineIndex][rowIndex] === EMPTY_BLOCK) {
        continue
      }
      
      newGrid[gridY][gridX] = clear ? EMPTY_BLOCK : piece[lineIndex][rowIndex]
    }
  }

  return newGrid
}

function rotatePiece(piece, flipX, flipY) {
  const result = new Array(piece[0].length).fill().map(a => new Array(piece.length).fill())
  for (lineIdx in piece) {
    const rows = piece[lineIdx].split('')
    for (rowIdx in rows) {
      result[rowIdx][lineIdx] = rows[rowIdx]
    }
  }
  
  return result.map(line => line.reverse().join(''))
}

function collides(grid1, grid2) {
  for (let y = 0; y < grid1.length; y++) {
    for (let x = 0; x < grid1[y].length; x++) {
      if (grid1[y][x] !== EMPTY_BLOCK && grid2[y][x] !== EMPTY_BLOCK) {
        return true
      }
    }
  }
  return false
}

function flushLines(grid) {
  const result = grid.filter((line) => !line.every(char => char === SOLID_BLOCK))
  const linesFlushed = HEIGHT - result.length

  if (linesFlushed > 0) {
    const multiplier = linesFlushed * 10
    score += linesFlushed * multiplier

    const gridPadding = getGrid().slice(0, linesFlushed)

    return [...gridPadding, ...result]
  }

  return result
}

function renderGrid(grid) {
  const gridString = grid.map(line => line.join('')).join('\n')
  output.innerHTML = gridString

  stats.innerHTML = `score: ${score} ${scoreAnimal}`
}

function mergeGrids(grid1, grid2) {
  const result = grid1
    .map((line, lineIdx) =>
      line.map((row, rowIdx) =>
        grid2[lineIdx][rowIdx] !== EMPTY_BLOCK ? grid2[lineIdx][rowIdx] : row)
      )

  return result
}

let isFirstTick = true
let score = -1
let bgGrid = getGrid()
let fgGrid
let currentPiece
let currentPieceX
let currentPieceY
let flipX
let flipY
let run = true
let ticksTillFall = TICKS_TILL_FALL

window['_state'] = {
  score,
  bgGrid,
  fgGrid,
  piece: {  
    currentPiece,
    currentPieceX,
    currentPieceY,
  },
  flipX,
  flipY,
  run,
  speed: MS_PER_TICK,
}

function initPiece() {
  score++
  currentPiece = getRandomPiece()
  currentPieceX = WIDTH / 2 - 2
  currentPieceY = -1
  fgGrid = getGrid()
  flipX = false
  flipY= true

  window['_state'].fgGrid = fgGrid
}


function tick() {
  if (!run) {
    return
  }

  const oldY = currentPieceY
  const oldX = currentPieceX

  try {
    const reachedFallThreshold = ticksTillFall <= 0

    if (reachedFallThreshold || isFirstTick) {

      const metBottom = (currentPieceY + currentPiece.length > bgGrid.length - 1)
      const hasCollision = metBottom || collides(bgGrid, drawPiece(fgGrid, currentPiece, currentPieceX, currentPieceY + 1))
      
      if (hasCollision) {
        ticksTillFall = TICKS_TILL_FALL // ticksTillFall * .1 // courtesy move has less time
      } else {
        ticksTillFall = TICKS_TILL_FALL
        currentPieceY++
      }

      fgGrid = drawPiece(fgGrid, currentPiece, oldX, oldY, true)
      fgGrid = drawPiece(fgGrid, currentPiece, currentPieceX, currentPieceY)

      if (hasCollision) {
        bgGrid = drawPiece(bgGrid, currentPiece, currentPieceX, currentPieceY)
        initPiece()
        bgGrid = flushLines(bgGrid)
      }

      window['_state'].bgGrid = bgGrid
      renderGrid(mergeGrids(fgGrid, bgGrid))
    } else {
      ticksTillFall--
    }

    window['_state'].ticksTillFall = ticksTillFall
  } catch (e) {
    clearInterval(tickerTimer)
    throw e
  }

  isFirstTick = false
  window.tickerTimer = setTimeout(tick, window['_state'].speed)
}

function cleanupOldInstance() {
  document.body.innerHTML = ''
  document.body.style.backgroundColor = '#fff'
  document.body.style.margin = ''
  document.body.style.padding = ''
  document.body.style.textAlign = 'center'
  clearTimeout(window.tickerTimer)
}

cleanupOldInstance()

const output = document.createElement('pre')
output.style.lineHeight = '.612'
output.style.fontSize = '250%'
output.style.display = 'inline-block'
output.style.border = '1px solid #ccc'
output.style.margin = '3vh 0 0'
document.body.appendChild(output)

const stats = document.createElement('pre')
document.body.appendChild(stats)

initPiece()
tick()


let touchXStart = 0
let touchYStart = 0
let touchedXBy = 0
let touchedYBy = 0
let pieceMoved = false
let movingDimension = ''

function controlPiece(direction, by = 1) {
  fgGrid = drawPiece(fgGrid, currentPiece, currentPieceX, currentPieceY, true)

  switch (direction) {
    case 'rotate':
      currentPiece = rotatePiece(currentPiece, flipX, flipY)
      flipX = !flipX
      flipY = !flipY

      if (currentPieceX + currentPiece[0].length > WIDTH) {
        currentPieceX--
      }
      break
    case 'left':
      if (!collides(bgGrid, drawPiece(fgGrid, currentPiece, currentPieceX - by, currentPieceY)) && currentPieceX - by + 1 > 0) {
        currentPieceX -= by
      }
      break
    case 'right':
      if (!collides(bgGrid, drawPiece(fgGrid, currentPiece, currentPieceX + by, currentPieceY)) && currentPieceX + currentPiece[0].length + by - 1 < WIDTH) {
        currentPieceX += by
      }
      break
    case 'down':
      ticksTillFall -= FALL_SPEED * by
      break
  }

  fgGrid = drawPiece(fgGrid, currentPiece, currentPieceX, currentPieceY)
  renderGrid(mergeGrids(fgGrid, bgGrid))
}

document.addEventListener("touchstart", (e) => {
  e.preventDefault()
  touchXStart = e.touches[0].pageX
  touchYStart = e.touches[0].pageY
}, { passive: false });

document.addEventListener("touchmove", (e) => {
  e.preventDefault()
  const pageX = e.touches[0].pageX
  const pageY = e.touches[0].pageY
  touchedXBy = Math.round((pageX - touchXStart) / TOUCH_MOVE_THRESHOLD)
  touchedYBy = Math.round((pageY - touchYStart) / TOUCH_MOVE_THRESHOLD)
  pieceMoved = touchedXBy || touchedYBy || pieceMoved

  if ((!movingDimension || movingDimension === 'x') && touchedXBy < 0) {
    controlPiece('left', -touchedXBy)
    movingDimension = 'x'
  }

  if ((!movingDimension || movingDimension === 'x') && touchedXBy > 0) {
    controlPiece('right', touchedXBy)
    movingDimension = 'x'
  }

  if ((!movingDimension || movingDimension === 'y') && touchedYBy > 0) {
    controlPiece('down', touchedYBy)
    movingDimension = 'y'
  }

  touchXStart = touchedXBy ? pageX : touchXStart
  touchYStart = touchedYBy ? pageY : touchYStart
}, { passive: false });

document.addEventListener('touchend', () => {
  if (!pieceMoved) {
    controlPiece('rotate')
  }

  pieceMoved = false
  touchedXBy = 0
  movingDimension = ''
})

window.addEventListener('keydown', ({ key }) => {
  const control = key.toLowerCase()

  if (!['arrowleft', 'arrowright', 'arrowup', 'arrowdown', 'p'].includes(control)) {
    return
  }  

  if (control === 'arrowup') {
    controlPiece('rotate')
  }

  if (control === 'arrowdown') {
    controlPiece('down')
  }
  
  if (control === 'arrowleft') {
    controlPiece('left')
  }

  if (control === 'arrowright' && currentPieceX + currentPiece[0].length < WIDTH) {
    controlPiece('right')
  }

  if (control === 'p') {
    run = !run

    if (run) {
      tick()
    }
  }
})
    </script>
  </body>
</html>