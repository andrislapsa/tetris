<html>
  <head>
    <meta charset="utf-8" />
    <style>
      body {
        font-size: 2vh;
        display: flex;
        gap: 30px;
      }
      /*@media(prefers-color-scheme:dark){body{background-color:rgb(50,54,57);}}*/

      .text-renderer .grid {
        line-height: .612;
        font-size: 250%;
        display: inline-block;
        border: 1px solid #ccc;
        margin: 3vh 0 0;
      }

      .canvas-renderer {
        border: 1px solid salmon;
      }
    </style>
    <title>Tetris</title>
  </head>
  <body>
    <div class="text-renderer">
      <pre class="grid"></pre>
      <pre class="stats"></pre>
    </div>
    <div class="canvas-renderer" style="width: 400px; height: 800px;">
      <canvas width="400" height="800" />
    </div>
    <script>
const output = document.querySelector('.text-renderer .grid')

const WIDTH = 12
const HEIGHT = WIDTH * 2
const EMPTY_BLOCK = ' '
const SOLID_BLOCK = 'â–£' // â–¦ â–£ â–¢
const scoreAnimal = 'ðŸ«'
const MS_PER_TICK = 1000 / 60 // ms for 60FPS
const TICKS_TILL_FALL = 40
const TOUCH_MOVE_THRESHOLD = 100
const FALL_SPEED = 40
const INITIAL_SPEED_COEFF = 1.5
const PIECES = [
  // [
  //   SOLID_BLOCK,
  //   SOLID_BLOCK,
  //   SOLID_BLOCK,
  //   SOLID_BLOCK,
  // ],
  [
    `${SOLID_BLOCK}${SOLID_BLOCK}`,
    `${SOLID_BLOCK}${SOLID_BLOCK}`,
  ],
  [
    `${SOLID_BLOCK} `,
    `${SOLID_BLOCK} `,
    `${SOLID_BLOCK}${SOLID_BLOCK}`,
  ],
  // [
  //   `${SOLID_BLOCK}${SOLID_BLOCK} `,
  //   ` ${SOLID_BLOCK}${SOLID_BLOCK}`,
  // ],
  // [
  //   ` ${SOLID_BLOCK}${SOLID_BLOCK}`,
  //   `${SOLID_BLOCK}${SOLID_BLOCK} `,
  // ],
  // [
  //   ` ${SOLID_BLOCK}`,
  //   ` ${SOLID_BLOCK}`,
  //   `${SOLID_BLOCK}${SOLID_BLOCK}`,
  // ],
  // [
  //   `${SOLID_BLOCK} `,
  //   `${SOLID_BLOCK}${SOLID_BLOCK}`,
  //   `${SOLID_BLOCK} `,
  // ],
]

class Tetris {
  isFirstTick = true
  score = -1
  bgGrid = Tetris.getGrid()
  fgGrid = undefined
  currentPiece = undefined
  currentPieceX = 0
  currentPieceY = 0
  flipX = false
  flipY = false
  run = true
  ticksTillFall = TICKS_TILL_FALL
  tickSpeedCoeff = INITIAL_SPEED_COEFF // lower number means faster
  render = () => {}

  constructor(render) {
    this.render = render
  }

  static rotatePiece(piece, flipX, flipY) {
    const result = new Array(piece[0].length).fill().map(a => new Array(piece.length).fill())
    for (let lineIdx in piece) {
      const rows = piece[lineIdx].split('')
      for (let rowIdx in rows) {
        result[rowIdx][lineIdx] = rows[rowIdx]
      }
    }
    
    return result.map(line => line.reverse().join(''))
  }

  static collides(grid1, grid2) {
    for (let y = 0; y < grid1.length; y++) {
      for (let x = 0; x < grid1[y].length; x++) {
        if (grid1[y][x] !== EMPTY_BLOCK && grid2[y][x] !== EMPTY_BLOCK) {
          return true
        }
      }
    }
    return false
  }

  static mergeGrids(grid1, grid2) {
    const result = grid1
      .map((line, lineIdx) =>
        line.map((row, rowIdx) =>
          grid2[lineIdx][rowIdx] !== EMPTY_BLOCK ? grid2[lineIdx][rowIdx] : row)
        )

    return result
  }

  static getRandomPiece = () => PIECES[Math.floor(Math.random() * PIECES.length)]

  static getGrid = () => new Array(HEIGHT).fill(undefined).map(a => new Array(WIDTH).fill(EMPTY_BLOCK))

  static drawPiece(grid, piece, x, y, clear = false) {
    const newGrid = [...grid.map(line => [...line])]
    for (let lineIndex in piece) {
      const line = piece[lineIndex].split('')

      for (let rowIndex in line) {
        const gridY = parseInt(lineIndex) + y
        const gridX = parseInt(rowIndex) + x

        if (newGrid[gridY] === undefined || newGrid[gridX] === undefined) {
          continue
        }

        if (piece[lineIndex][rowIndex] === EMPTY_BLOCK) {
          continue
        }
        
        newGrid[gridY][gridX] = clear ? EMPTY_BLOCK : piece[lineIndex][rowIndex]
      }
    }

    return newGrid
  }

  initPiece() {
    this.score++
    this.currentPiece = Tetris.getRandomPiece()
    this.currentPieceX = WIDTH / 2 - 2
    this.currentPieceY = -1
    this.fgGrid = Tetris.getGrid()
    this.flipX = false
    this.flipY= true
  }

  flushLines(grid) {
    const result = grid.filter((line) => !line.every(char => char === SOLID_BLOCK))
    const linesFlushed = HEIGHT - result.length

    if (linesFlushed > 0) {
      const multiplier = linesFlushed * 10
      this.score += linesFlushed * multiplier

      const minSpeedCoeff = .1
      // this.tickSpeedCoeff = Math.max(INITIAL_SPEED_COEFF - this.score / 500, minSpeedCoeff)

      const gridPadding = Tetris.getGrid().slice(0, linesFlushed)

      return [...gridPadding, ...result]
    }

    return result
  }

  controlPiece(direction, by = 1) {
    this.fgGrid = Tetris.drawPiece(this.fgGrid, this.currentPiece, this.currentPieceX, this.currentPieceY, true)

    switch (direction) {
      case 'rotate':
        this.currentPiece = Tetris.rotatePiece(this.currentPiece, this.flipX, this.flipY)
        this.flipX = !this.flipX
        this.flipY = !this.flipY

        if (this.currentPieceX + this.currentPiece[0].length > WIDTH) {
          this.currentPieceX--
        }
        break
      case 'left':
        if (!Tetris.collides(this.bgGrid, Tetris.drawPiece(
          this.fgGrid,
          this.currentPiece,
          this.currentPieceX - by,
          this.currentPieceY
        )) && this.currentPieceX - by + 1 > 0) {
          this.currentPieceX -= by
        }
        break
      case 'right':
        if (!Tetris.collides(this.bgGrid, Tetris.drawPiece(
          this.fgGrid,
          this.currentPiece,
          this.currentPieceX + by,
          this.currentPieceY
        )) && this.currentPieceX + this.currentPiece[0].length + by - 1 < WIDTH) {
          this.currentPieceX += by
        }
        break
      case 'down':
        this.ticksTillFall -= FALL_SPEED * by
        break
    }

    this.fgGrid = Tetris.drawPiece(this.fgGrid, this.currentPiece, this.currentPieceX, this.currentPieceY)
    this.render(Tetris.mergeGrids(this.fgGrid, this.bgGrid))
  }

  tick() {
    if (!this.run) {
      return
    }

    const oldY = this.currentPieceY
    const oldX = this.currentPieceX

    try {
      const reachedFallThreshold = this.ticksTillFall <= 0

      if (reachedFallThreshold || this.isFirstTick) {

        const metBottom = (this.currentPieceY + this.currentPiece.length > this.bgGrid.length - 1)
        const hasCollision = metBottom || Tetris.collides(this.bgGrid, Tetris.drawPiece(
          this.fgGrid, this.currentPiece, this.currentPieceX, this.currentPieceY + 1)
        )
        
        if (hasCollision) {
          this.ticksTillFall = 0
        } else {
          this.ticksTillFall = TICKS_TILL_FALL * this.tickSpeedCoeff
          this.currentPieceY++
        }

        this.fgGrid = Tetris.drawPiece(this.fgGrid, this.currentPiece, oldX, oldY, true)
        this.fgGrid = Tetris.drawPiece(this.fgGrid, this.currentPiece, this.currentPieceX, this.currentPieceY)

        if (hasCollision) {
          this.bgGrid = Tetris.drawPiece(this.bgGrid, this.currentPiece, this.currentPieceX, this.currentPieceY)
          this.initPiece()
          this.bgGrid = this.flushLines(this.bgGrid)
        }

        this.render(Tetris.mergeGrids(this.fgGrid, this.bgGrid))
      } else {
        this.ticksTillFall--
      }
    } catch (e) {
      clearInterval(window.tickerTimer)
      throw e
    }

    this.isFirstTick = false
    window.tickerTimer = setTimeout(() => this.tick(), this.speed)
  }
}

function renderGrid(grid) {
  const gridString = grid.map(line => line.join('')).join('\n')
  output.innerHTML = gridString

  stats.innerHTML = `score: ${game.score} ${scoreAnimal}`
}

const canvas = document.querySelector('.canvas-renderer canvas')
const canvasCtx = canvas.getContext('2d')
const BLOCK_R = 33.3333

function renderCanvas(grid) {
  canvasCtx.clearRect(0, 0, 400, 800)

  for (let row = 0; row < grid.length; row++) {
    for (let column = 0; column < grid[row].length; column++) {
      // console.log('hmm', { row, column })
      if (grid[row][column] === SOLID_BLOCK) {
        // console.log('block at', { row, column })
        canvasCtx.fillRect(column * BLOCK_R, row * BLOCK_R, BLOCK_R - 2, BLOCK_R - 2)
      }
    }
  }
}

const game = new Tetris((gridState) => {
  // console.log('renderer', gridState)
  renderGrid(gridState)
  renderCanvas(gridState)
})
window.game = game

const stats = document.querySelector('.text-renderer .stats')

game.initPiece()
game.tick()


let touchXStart = 0
let touchYStart = 0
let touchedXBy = 0
let touchedYBy = 0
let pieceMoved = false
let movingDimension = ''

document.addEventListener("touchstart", (e) => {
  e.preventDefault()
  touchXStart = e.touches[0].pageX
  touchYStart = e.touches[0].pageY
}, { passive: false });

document.addEventListener("touchmove", (e) => {
  e.preventDefault()
  const pageX = e.touches[0].pageX
  const pageY = e.touches[0].pageY
  touchedXBy = Math.round((pageX - touchXStart) / TOUCH_MOVE_THRESHOLD)
  touchedYBy = Math.round((pageY - touchYStart) / TOUCH_MOVE_THRESHOLD)
  pieceMoved = touchedXBy || touchedYBy || pieceMoved

  if ((!movingDimension || movingDimension === 'x') && touchedXBy < 0) {
    game.controlPiece('left', -touchedXBy)
    movingDimension = 'x'
  }

  if ((!movingDimension || movingDimension === 'x') && touchedXBy > 0) {
    game.controlPiece('right', touchedXBy)
    movingDimension = 'x'
  }

  if ((!movingDimension || movingDimension === 'y') && touchedYBy > 0) {
    game.controlPiece('down', touchedYBy)
    movingDimension = 'y'
  }

  touchXStart = touchedXBy ? pageX : touchXStart
  touchYStart = touchedYBy ? pageY : touchYStart
}, { passive: false });

document.addEventListener('touchend', () => {
  if (!pieceMoved) {
    game.controlPiece('rotate')
  }

  pieceMoved = false
  touchedXBy = 0
  movingDimension = ''
})

window.addEventListener('keydown', ({ key }) => {
  const control = key.toLowerCase()

  if (!['arrowleft', 'arrowright', 'arrowup', 'arrowdown', 'p', 'w', 'a', 's', 'd'].includes(control)) {
    return
  }  

  if (control === 'arrowup' || control === 'w') {
    game.controlPiece('rotate')
  }

  if (control === 'arrowdown' || control === 's') {
    game.controlPiece('down')
  }
  
  if (control === 'arrowleft' || control === 'a') {
    game.controlPiece('left')
  }

  if (control === 'arrowright' || control === 'd') {
    game.controlPiece('right')
  }

  if (control === 'p') {
    game.run = !game.run

    if (game.run) {
      game.tick()
    }
  }
})
    </script>
  </body>
</html>